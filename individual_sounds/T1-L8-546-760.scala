play {
RandSeed.ir(1, 2)
val bRF_0   = BRF.ar(Seq(695.37335, 695.38), freq = 0.76825744, rq = 419.73846)
val a       = LeastChange.ar(a = Seq.fill(2)(0.76825744), b = 0.26494086)
val b_0     = Pulse.ar(freq = -0.014119833, width = 0.3661115)
val in_0    = QuadC.ar(freq = 0.42893913, a = a, b = b_0, c = 0.01778894, xi = 0.01778894)
val prob    = RunningMax.ar(in_0, trig = 732.2712)
val time    = LeastChange.ar(a = 0.26494086, b = 388.64276)
val decay   = Decay.ar(Seq(683.00226, 683.01), time = time)
val lag3    = Lag3.ar(Seq(695.37335, 695.38), time = time)
val varSaw  = VarSaw.ar(freq = Seq(-0.4377183, -0.438), iphase = 103.6289, width = -0.014119833)
val gbmanL  = GbmanL.ar(freq = Seq(388.64276, 388.65), xi = -2529.0552, yi = 419.73846)
val tWindex = TWindex.ar(trig = 388.64276, prob = prob, normalize = -0.0029116)
val slope   = Slope.ar(Seq(683.00226, 683.01))
val bPZ2    = BPZ2.ar(Seq(419.73846, 419.74))
val bRF_1   = BRF.ar(Seq(103.6289, 103.64), freq = -2029.8915, rq = -2029.8915)
val mix     = Mix(Seq[GE](bRF_1, bPZ2, slope, tWindex, gbmanL, varSaw, lag3, decay, bRF_0))
val mix_0   = mix // Mix.mono(mix)
val bad       = CheckBadValues.ar(mix_0, id = 0.0, post = 0.0)
val gate      = Gate.ar(mix_0, gate = bad sig_== 0.0)
val lim       = LeakDC.ar(Limiter.ar(LeakDC.ar(gate, coeff = 0.995), level = 1.0, dur = 0.01), coeff = 0.995)
// val fade   = DelayN.ar(FadeIn(audio, "fade-in"), maxDelayTime = 0.02, delayTime = 0.02) * FadeOut(audio, "fade-out") * 1.0 - Attribute(control, "mute", 0.0) * Attribute(control, "gain", 1.0)
// ScanOut("out", lim * fade)
lim // Pan2.ar(lim)
}
