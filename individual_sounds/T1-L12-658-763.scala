play {
RandSeed.ir(1, 4)
val freq        = Slope.ar(Seq(633.6489, 633.7))
val up          = VarSaw.ar(freq = freq, iphase = 0.38882363, width = -0.4713431)
val xi          = Slew.ar(633.6489, up = up, down = 1.0513319)
val leastChange = LeastChange.ar(a = Seq(-173.14772, -173.2), b = 633.6489)
val decay       = QuadC.ar(freq = 0.38882363, a = 9.444879E-4, b = 695.37335, c = leastChange, xi = xi)
val in_0        = Ringz.ar(419.73846, freq = 436.66745, decay = decay)
val bRF         = BRF.ar(in_0, freq = -0.0029116, rq = 419.73846)
val gbmanL      = GbmanL.ar(freq = Seq(453.7693, 453.8), xi = 0.3661115, yi = -2726.2134)
val in_1        = Decay.ar(leastChange, time = 667.69073)
val delayC      = DelayC.ar(in_1, maxDelayTime = 0.0015029017, delayTime = 0.0015029017)
val slope       = Slope.ar(Seq(695.37335, 695.4))
val stepper     = Stepper.ar(trig = -2529.0552, reset = 0.0015029017, lo = 633.6489, hi = 419.73846, 
  step = Seq(0.3661115, 0.37), resetVal = -0.21497793)
val mix         = Mix(Seq[GE](stepper, slope, delayC, gbmanL, bRF))
val mix_0   = mix // Mix.mono(mix)
val bad       = CheckBadValues.ar(mix_0, id = 0.0, post = 0.0)
val gate      = Gate.ar(mix_0, gate = bad sig_== 0.0)
val lim       = LeakDC.ar(Limiter.ar(LeakDC.ar(gate, coeff = 0.995), level = 1.0, dur = 0.01), coeff = 0.995)
// val fade   = DelayN.ar(FadeIn(audio, "fade-in"), maxDelayTime = 0.02, delayTime = 0.02) * FadeOut(audio, "fade-out") * 1.0 - Attribute(control, "mute", 0.0) * Attribute(control, "gain", 1.0)
// ScanOut("out", lim * fade)
lim // Pan2.ar(lim)
}
